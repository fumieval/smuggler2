{-# LANGUAGE LambdaCase #-}

module Smuggler.Plugin
  ( plugin,
  )
where

import Avail (AvailInfo (AvailTC), Avails, availNamesWithSelectors)
import Control.Monad (unless, when)
import Control.Monad.IO.Class (MonadIO (liftIO))
import Data.Maybe (fromMaybe, isNothing)
import DynFlags (DynFlags (dumpDir), HasDynFlags (getDynFlags))
import GHC
  ( GenLocated (L),
    GhcPs,
    HsModule (hsmodExports, hsmodImports),
    ImportDecl (ideclHiding, ideclImplicit),
    LIE,
    LImportDecl,
    Located,
    ModSummary (ms_hspp_buf, ms_hspp_file, ms_mod),
    Module (moduleName),
    Name,
    ParsedSource,
    moduleNameString,
    unLoc,
  )
import GHC.IO.Encoding (setLocaleEncoding, utf8)
import IOEnv (readMutVar)
import Language.Haskell.GHC.ExactPrint
  ( Anns,
    TransformT,
    exactPrint,
    graftT,
    runTransform,
    setEntryDPT,
  )
import Language.Haskell.GHC.ExactPrint.Types (DeltaPos (DP))
import Outputable (Outputable (ppr), neverQualify, printForUser, vcat)
import Plugins
  ( CommandLineOption,
    Plugin (pluginRecompile, typeCheckResultAction),
    defaultPlugin,
    purePlugin,
  )
import RdrName (GlobalRdrEnv, globalRdrEnvElts, gresToAvailInfo, isLocalGRE)
import RnNames (ImportDeclUsage, findImportUsage, getMinimalImports)
import Smuggler.Anns (addCommaT, addExportDeclAnnT, mkLIEVarFromNameT, mkLoc, mkParenT)
import Smuggler.Options
  ( ExportAction (AddExplicitExports, NoExportProcessing, ReplaceExports),
    ImportAction (MinimiseImports, NoImportProcessing),
    Options (exportAction, importAction, newExtension),
    parseCommandLineOptions,
  )
import Smuggler.Parser (runParser)
import StringBuffer (StringBuffer (StringBuffer), lexemeToString)
import System.Directory (removeFile)
import System.FilePath ((-<.>), (</>))
import System.IO (IOMode (WriteMode), withFile)
import TcRnTypes (RnM, TcGblEnv (tcg_rdr_env, tcg_exports, tcg_rn_imports, tcg_used_gres), TcM)

plugin :: Plugin
plugin =
  defaultPlugin
    { typeCheckResultAction = smugglerPlugin,
      pluginRecompile = purePlugin -- Don't force recompilation.  [Is this the right approach?]
    }

-- | The plugin itself
smugglerPlugin :: [CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv
smugglerPlugin clopts modSummary tcEnv = do
  -- bail quickly, if nothing to do
  when
    ( (importAction options == NoImportProcessing)
        && (exportAction options == NoExportProcessing)
    )
    $ pure ()

  -- Get the imports and their usage
  let imports = tcg_rn_imports tcEnv
  uses <- readMutVar $ tcg_used_gres tcEnv
  let usage = findImportUsage imports uses

  -- Dump GHC's view of a minimal set of imports
  dflags <- getDynFlags
  let minImpFilePath = mkFilePath dflags (ms_mod modSummary)
  printMinimalImports' dflags minImpFilePath usage

  tcEnv <$ liftIO (smuggling dflags minImpFilePath)
  where
    smuggling :: DynFlags -> FilePath -> IO ()
    smuggling dflags minImpFilePath = do
      let modulePath = ms_hspp_file modSummary

      --  Read files UTF-8 strings (GHC accepts only ASCII or UTF-8)
      setLocaleEncoding utf8

      -- Get the pre-processed source code
      let modFileContents = case ms_hspp_buf modSummary of
            -- Not clear under what circumstances this could happen
            Nothing -> error $ "smuggler: missing source file: " ++ modulePath
            Just contents -> strBufToStr contents

      -- parse the whole module
      runParser dflags modulePath modFileContents >>= \case
        Left () -> pure () -- do nothing if file is invalid Haskell
        Right (annsHsMod, astHsMod) -> do
          -- read the GHC-dumped file of minimal imports
          minImpFileContents <- readFile minImpFilePath

          -- parse the minimal imports file
          runParser dflags minImpFilePath minImpFileContents >>= \case
            Left () -> error $ "smuggler: failed to parse minimal imports from " ++ minImpFilePath
            Right (annsImpMod, L _ impMod) -> do
              -- The actual minimal imports themselves, as generated by GHC
              let minImports = hsmodImports impMod

              -- What is exported by the module
              -- TODO: prseumably this is not the same as what is exportable,
              -- which means that the rewrite exports action will not do much
              let exports =
                    if exportAction options == ReplaceExports
                      then exportable $ tcg_rdr_env tcEnv
                      else tcg_exports tcEnv

              -- Bringing it all together: generate a new ast and annotations for it
              let (astHsMod', (annsHsMod', _locIndex), _log) =
                    runTransform annsHsMod $
                      replaceImports annsImpMod minImports astHsMod
                        >>= addExplicitExports exports

              -- Print the result
              let newContent = exactPrint astHsMod' annsHsMod'
              case newExtension options of
                Nothing -> writeFile modulePath newContent
                Just ext -> writeFile (modulePath -<.> ext) newContent

              -- delete the
              removeFile minImpFilePath
          where
            -- A cut down veersion of
            exportable :: GlobalRdrEnv -> [AvailInfo]
            exportable rdr_env =
              -- The same as (module M) where M is the current module name,
              -- so that's how we handle it, except we also export the data amily
              -- when a data instance is exported.
              map fix_faminst . gresToAvailInfo
                . filter isLocalGRE
                . globalRdrEnvElts
                $ rdr_env
              where
                fix_faminst (AvailTC n ns flds) =
                  let new_ns =
                        case ns of
                          [] -> [n]
                          (p : _) -> if p == n then ns else n : ns
                   in AvailTC n new_ns flds
                fix_faminst avail = avail

            --  Replace a target module's imports
            --  See <https://github.com/facebookincubator/retrie/blob/master/Retrie/CPP.hs>
            replaceImports ::
              Monad m =>
              -- | annotations for the replacement imports
              Anns ->
              -- | the replacement imports
              [LImportDecl GhcPs] ->
              -- | target module
              ParsedSource ->
              TransformT m ParsedSource
            replaceImports anns minImports t@(L l m) =
              case action of
                NoImportProcessing -> return t
                _ -> do
                  imps <- graftT anns minImports
                  -- nudge down the imports list onto a new line
                  unless (null imps) $ setEntryDPT (head imps) (DP (2, 0))
                  return $ L l m {hsmodImports = imps}
              where
                action :: ImportAction
                action = importAction options

            -- Add explict exports to the target module
            addExplicitExports ::
              Monad m =>
              -- | The list of exports to be added
              Avails ->
              -- | target module
              ParsedSource ->
              TransformT m ParsedSource
            addExplicitExports exports t@(L astLoc hsMod) =
              case exportAction options of
                NoExportProcessing -> return t
                AddExplicitExports ->
                  -- only add explicit exports if there are none
                  -- seems to work even if there is no explict module declaration
                  -- presumably because the annotations that we generate are just
                  -- unused by exactPrint
                  if isNothing currentExplicitExports then result else return t
                ReplaceExports -> result
              where
                currentExplicitExports :: Maybe (Located [LIE GhcPs])
                currentExplicitExports = hsmodExports hsMod

                names :: [Name]
                names = reverse $ mkNamesFromAvailInfos exports -- TODO check the ordering

                -- Produces all names from the availability information (including overloaded selectors)
                -- To exclude overloaded selector use availNames
                mkNamesFromAvailInfos :: Avails -> [Name]
                mkNamesFromAvailInfos = concatMap availNamesWithSelectors

                -- This does all the export replacement work
                result :: Monad m => TransformT m ParsedSource
                result
                  | null names = return t
                  | otherwise = do
                    -- Generate the exports list
                    exportsList <- mapM mkLIEVarFromNameT names
                    -- add further annotations
                    mapM_ addExportDeclAnnT exportsList
                    mapM_ addCommaT (init exportsList)

                    -- Add the parens
                    lExportsList <- mkLoc exportsList >>= mkParenT unLoc

                    -- No need to do any graftTing here as we have been modifying the
                    -- annotations in the current transformation
                    return $ L astLoc hsMod {hsmodExports = Just lExportsList}

    -- This version of the GHC function ignores implicit imports, as the result
    -- cannot be parsed back in.  (There is an extraneous (implicit)')
    -- It also provides for leaving out instance-only imports (eg, Data.List() )
    printMinimalImports' :: DynFlags -> FilePath -> [ImportDeclUsage] -> RnM ()
    printMinimalImports' dflags filename imports_w_usage =
      do
        imports' <- getMinimalImports imports_w_usage
        liftIO $
          withFile
            filename
            WriteMode
            ( \h ->
                -- The neverQualify is important.  We are printing Names
                -- but they are in the context of an 'import' decl, and
                -- we never qualify things inside there
                -- E.g.   import Blag( f, b )
                -- not    import Blag( Blag.f, Blag.g )!
                printForUser dflags h neverQualify (vcat (map ppr (filter (letThrough . unLoc) imports')))
            )
      where
        notImplicit :: ImportDecl pass -> Bool
        notImplicit = not . ideclImplicit

        notInstancesOnly :: ImportDecl pass -> Bool
        notInstancesOnly i = case ideclHiding i of
          Just (False, L _ []) -> False
          _ -> True

        keepInstanceOnlyImports :: Bool
        keepInstanceOnlyImports = importAction options /= MinimiseImports

        letThrough :: ImportDecl pass -> Bool
        letThrough i = notImplicit i && (keepInstanceOnlyImports || notInstancesOnly i)

    mkFilePath :: DynFlags -> Module -> FilePath
    mkFilePath dflags this_mod
      | Just d <- dumpDir dflags = d </> basefn
      | otherwise = basefn
      where
        basefn =
          "smuggler-" ++ moduleNameString (moduleName this_mod) ++ "."
            ++ fromMaybe "smuggler" (newExtension options)
            ++ ".imports"

    options :: Options
    options = parseCommandLineOptions clopts

    strBufToStr :: StringBuffer -> String
    strBufToStr sb@(StringBuffer _ len _) = lexemeToString sb len
